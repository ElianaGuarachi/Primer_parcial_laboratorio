
#include "Informes.h"

int ListadoDeClientesContandoSusPedidosPendientes(eClientes clientes[], int tam_clientes, ePedidos pedidos[], int tam_pedidos)
{
	int retorno = -1;
	eAuxiliarContador pedidosPendientes[tam_clientes];
	if(pedidos != NULL && clientes != NULL && tam_pedidos > 0 && tam_clientes > 0)
	{
		if(InicializarAuxiliarContadorDePedidosPorCliente(clientes, tam_clientes, pedidosPendientes) == 0)
		{
			if(ContadorDePedidosPendientePorCliente(pedidos, tam_pedidos, pedidosPendientes, tam_clientes) == 0)
			{
				printf("\nID CLIENTE \tNOMBRE DE LA EMPRESA    \t\tCUIT   \t\t\tDIRECCION \t\t       LOCALIDAD   \tPEDIDOS PENDIENTES\n");
				MostrarListaDeClientesConSusPedidosPendientes(clientes, tam_clientes, pedidosPendientes);
				retorno=0;
			}
			else
			{
				printf("\nCONTEO MALO");
			}
		}
	}

	return retorno;
}

int ContadorDePedidosPendientePorCliente(ePedidos pedidos[], int tam_pedidos, eAuxiliarContador pedidosPendientes[], int tam_pendientes)
{
	int retorno=-1;
	int i;
	int j;
	if(pedidos != NULL && tam_pedidos > 0 && tam_pendientes > 0 && pedidosPendientes != NULL)
	{
		for(j=0; j<tam_pendientes; j++)
		{
			for(i=0; i<tam_pedidos; i++)
			{
				if(pedidosPendientes[j].id == pedidos[i].idCliente && pedidos[i].estado == PENDIENTE && pedidos[i].isEmpty == OCUPADO)
				{
					pedidosPendientes[j].contador++;
					retorno = 0;
				}
			}
		}
	}
	return retorno;
}

int InicializarAuxiliarContador(eClientes clientes[], int tam_clientes, eAuxiliarContador auxiliar[])
{
	int retorno = -1;
	int i;
	if(clientes != NULL && auxiliar != NULL && tam_clientes > 0)
	{
		for(i=0; i<tam_clientes; i++)
		{
			auxiliar[i].id = clientes[i].idCliente; //se inicializa con el id de los clientes
			auxiliar[i].contador = 0;
			auxiliar[i].acumulador = 0;
			retorno = 0;
		}
	}
	return retorno;
}


int MostrarListaDeClientesConSusPedidosPendientes(eClientes clientes[], int tam_clientes, eAuxiliarContador pedidosPendiente[])
{
	int retorno=-1;
	int i;
	if(clientes != NULL && tam_clientes > 0  && pedidosPendiente != NULL)
	{
		for(i=0; i<tam_clientes; i++)
		{
			if(clientes[i].isEmpty == OCUPADO)
			{
				MostrarClienteConSusPedidosPendientes(clientes[i], tam_clientes, pedidosPendiente);
				retorno = 0;
			}
		}
	}

	return retorno;
}


void MostrarClienteConSusPedidosPendientes(eClientes cliente, int tam_clientes, eAuxiliarContador pedidosPendientes[])
{
	int i;
	if(pedidosPendientes != NULL && tam_clientes > 0)
	{
		for(i=0; i < tam_clientes; i++)
		{
			if(pedidosPendientes[i].id == cliente.idCliente)
			{
				printf("\n%5d \t\t%20s \t%20s \t%25s %5d \t%20s \t\t%d", cliente.idCliente, cliente.nombreEmpresa, cliente.cuit,
						cliente.direccion.calle, cliente.direccion.numero, cliente.localidad, pedidosPendientes[i].contador);
			}
		}
	}
}

/*
 * 7) Imprimir Pedidos pendientes: Se imprimirá una lista de los pedidos que se encuentren en estado “Pendiente”
 * con la información: Cuit del cliente, dirección del cliente, cantidad de kilos a recolectar.
 *
 * */

int MostrarListaDePedidosEnEstadoPendiente(ePedidos pedidos[], int tam_pedidos, eClientes clientes[], int tam_clientes)
{
	int retorno=-1;
	int i;
	if(pedidos != NULL && clientes != NULL && tam_pedidos>0 && tam_clientes>0)
	{
		printf("\nID PEDIDO PENDIENTE \t\tCUIT EMPRESA \t\t\tDIRECCION \t\t TOTAL KG. DE RESIDUOS\n");
		for(i=0;i<tam_pedidos;i++)
		{
			if(pedidos[i].isEmpty == OCUPADO && pedidos[i].estado == PENDIENTE)
			{
				PedidoEnEstadoPerdienteConSuCliente(pedidos[i], tam_clientes, clientes);
				retorno=0;
			}
		}
		printf("\n");
	}
	return retorno;
}

void PedidoEnEstadoPerdienteConSuCliente(ePedidos pedidos, int tam_clientes, eClientes clientes[])
{
	int j;
	if(clientes != NULL && tam_clientes > 0)
	{
		for(j=0; j < tam_clientes; j++)
		{
			if(clientes[j].isEmpty == OCUPADO && clientes[j].idCliente == pedidos.idCliente)
			{
				printf("\n\t%d \t\t%20s \t%25s %5d \t%15.2f", pedidos.idPedido, clientes[j].cuit,
						clientes[j].direccion.calle, clientes[j].direccion.numero, pedidos.cantidadKilos);
			}
		}
	}
}

/*
 * 8) Imprimir Pedidos procesados: Se imprimirá una lista de los pedidos que se encuentren en estado “Completado”
 * con la información: Cuit del cliente, dirección del cliente, cantidad de kilos reciclados de cada tipo de plástico.
 *
 * */

int ImprimirPedidosProcesadosEnEstadoCompletado(ePedidos pedidos[], int tam_pedidos, eClientes clientes[], int tam_clientes)
{
	int retorno=-1;
	int i;
	if(pedidos != NULL && clientes != NULL && tam_pedidos>0 && tam_clientes>0)
	{
		printf("\nID PEDIDO COMPLETADO \t\tCUIT EMPRESA \t\t\tDIRECCION \t\t KG. HDPE \tKG. HDLE \t KG. PP\n");
		for(i=0;i<tam_pedidos;i++)
		{
			if(pedidos[i].isEmpty == OCUPADO && pedidos[i].estado == COMPLETADO)
			{
				PedidoEnEstadoCompletadoConInfoDeSuCliente(pedidos[i], tam_clientes, clientes);
				retorno=0;
			}
		}
		printf("\n");
	}
	return retorno;
}

void PedidoEnEstadoCompletadoConInfoDeSuCliente(ePedidos pedidos, int tam_clientes, eClientes clientes[])
{
	int j;
	if(clientes != NULL && tam_clientes > 0)
	{
		for(j=0; j < tam_clientes; j++)
		{
			if(clientes[j].isEmpty == OCUPADO && clientes[j].idCliente == pedidos.idCliente)
			{
				printf("\n\t %d \t\t%20s \t%25s %5d %15.2f %15.2f %15.2f", pedidos.idPedido, clientes[j].cuit,
						clientes[j].direccion.calle, clientes[j].direccion.numero, pedidos.tiposResiduos.pAltaDensidad,
						pedidos.tiposResiduos.pBajaDensidad, pedidos.tiposResiduos.polipropileno);
			}
		}
	}
}

//9) Ingresar una localidad e indicar la cantidad de pedidos pendientes para dicha localidad.

int CantidadPedidosPendientesPorLocalidad (ePedidos pedidos[], int tam_pedidos, eClientes clientes[], int tam_clientes)
{
	int retorno=-1;
	char localidadIngresada[51];
	int i;
	int j;
	int contador=0;

	if(pedidos != NULL && tam_pedidos > 0 && clientes != NULL && tam_clientes > 0)
	{
		if(ObtenerPalabras(localidadIngresada, "\nIngrese una localidad que desee buscar: ",
				"\nError. Ingrese la localidad nuevamente: ",1) == 1)
		{
			FormatearCadenaConNumeros(localidadIngresada);
			if(VerificarIngresoDeLocalidad(clientes, tam_clientes, localidadIngresada) == 0)
			{
				for(i=0; i< tam_pedidos;i++)
				{
					if(pedidos[i].isEmpty == OCUPADO)
					{
						BuscarEnListaDeClientesLaLocalidad(pedidos[i], clientes, tam_clientes, localidadIngresada);
						retorno=0;
					}
				}

			}
			else
			{
				printf("\nNo hay pedidos con la localidad que ingreso\n");
			}
		}
	}
	return retorno;
}

int ContarEnListaDeClientesLasLocalidadesConPedidosPendiente(ePedidos pedidos, eClientes clientes[], int tam_clientes, char localidadIngresada[])
{
	int retorno=-1;
	int contador=0;
	int j;
	if(clientes != NULL && tam_clientes)
	{
		for(j=0; j < tam_clientes; j++)
		{
			if(clientes[j].isEmpty == OCUPADO &&  pedidos.idCliente == clientes[j].idCliente && pedidos.estado == PENDIENTE &&
							stricmp(clientes[j].localidad, localidadIngresada)==0)
			{
				contador++;
				retorno=0;
			}
		}
	}
	return retorno;
}

int VerificarIngresoDeLocalidad(eClientes clientes[], int tam_clientes, char localidadIngresada[])
{
	int retorno=-1;
	int i;
	if(clientes != NULL && tam_clientes > 0)
	{
		for(i=0; i < tam_clientes; i++)
		{
			if(stricmp(clientes[i].localidad, localidadIngresada)==0)
			{
				retorno=0;
				break;
			}
		}
	}
	return retorno;
}

//10) Cantidad de kilos de polipropileno reciclado promedio por cliente. (kilos totales / cantidad de clientes)

// recorrer la lista de pedidos y preguntar por los completados
// recorrer la lista de clientes




